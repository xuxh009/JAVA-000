1.（必做） 根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 的总结，提交到 Github。
    1)第一感受是没有完美的GC算法，至于具体系统应该选用哪种垃圾回收器应该根据项目实际需要区选择。
      比如系统更注重的是高吞吐量还是低延迟，高吞吐量尽量选用并行收集器，低延迟的尽量选择使用CMS、G1并发收集器。
    2)在选择好合适是垃圾收集器后，要想达到更好的效果，实际项目还需要对虚拟机的各种参选进行调优，
      比如堆内存大小，新生代老年代空间比列、对象晋升代、元空间、、堆外内存大小等，不合理的参数配置可能会引起频繁GC，甚至OOM。
    3)对于堆内存的不同区域使用不同的垃圾收集算法，个人感觉这点很精妙，比如垃圾年轻代基本上是朝生夕死的对象，生命周期很短，故大多使用复制压缩算法。
      而老年代的对象大都存活时间很长，对象也比较的多，故使用标记清除算法，以避免大量复制操作节省系统资源。

2.（必做）写一段代码，使用 HttpClient 或 OkHttp 访问 http://localhost:8801 ，代码提交到 Github。
    见代码